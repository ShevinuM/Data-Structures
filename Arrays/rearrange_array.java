/**
 * You are given an array of integers 'a'. A new array 'b' is generated by rearranging 
 * the elements of 'a' in the following way:
 *
 * b[0] is equal to a[0];
 * b[1] is equal to the last element of a;
 * b[2] is equal to a[1];
 * b[3] is equal to the second-last element of a;
 * b[4] is equal to a[2];
 * b[5] is equal to the third-last element of a;
 * and so on.
 *
 * Your task is to determine whether the new array 'b' is sorted in strictly ascending order or not.
 *
 * Example:
 * 
 * For a = [1, 3, 5, 6, 4, 2], the output should be solution(a) = true.
 * The new array b will look like [1, 2, 3, 4, 5, 6], which is in strictly ascending order, so the answer is true.
 *
 * For a = [1, 4, 5, 6, 3], the output should be solution(a) = false.
 * The new array b will look like [1, 3, 4, 6, 5], which is not in strictly ascending order, so the answer is false.
 *
 * Input/Output:
 *
 * [execution time limit] 3 seconds (java)
 * [memory limit] 1 GB
 *
 * [input] array.integer a
 * The given array of integers.
 * Guaranteed constraints:
 * 1 ≤ a.length ≤ 105,
 * -109 ≤ a[i] ≤ 109.
 *
 * [output] boolean
 * A boolean representing whether the new array 'b' will be sorted in strictly ascending order or not.
 */
class Solution {
    public boolean solution(int[] a) {
    if (a.length == 1) { return true; } // return true if the length of a is 1 
    
    /***
        So to solve this problem, we can have two pointers on either side of a, one is the left pointer
        and the other is the right pointer. 
        Define a new array b of length a.length
        The loop runs while left <= right
        left is initialized to the first element
        right is initialized to the last element
        we use a index variable to keep track of the index to insert
        within the loop we add a[left] to b[count] then count++ and a[right] to b[count] then count++
        then left++ and right--
        special edge case -> left == right -> only a[left] is added and then left++ and right-- which
        will get us out of the loop
        Now we have created b.
    **/
    
    int[] b = new int[a.length];
    int left = 0;
    int right = a.length - 1; 
    int index = 0;
    
    while (left <= right) {
        if (left == right) {
            b[index] = a[left];
        } else {
            b[index] = a[left];
            index++;
            b[index] = a[right];
            index++;
        }
        left++;
        right--;
    }
    
    /*
        Now the next part is to determine if the array is sorted in strictly ascending order. So we
        iterate over the array and check if the next element is greater than previous
        We can have two variables, curr and next. 
        
        The for loop stops 1 before the last element to avoid overflowing when dealing with next
    */
    int curr, next;
    for (index = 0; index <= b.length - 2; index++) {
        curr = b[index];
        next = b[index+1];
        if (next <= curr) { return false; }
    }
    return true;
}
}
